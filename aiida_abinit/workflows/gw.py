# -*- coding: utf-8 -*-
"""Base Abinit WorkChain implementation."""
from aiida import orm
from aiida.common import AttributeDict, exceptions
from aiida.common.lang import type_check

from aiida.engine import WorkChain,  ToContext, if_, ProcessHandlerReport, process_handler, while_
from aiida.plugins import CalculationFactory

from aiida_abinit.utils import create_kpoints_from_distance, validate_and_prepare_pseudos_inputs
from aiida_quantumespresso.workflows.protocols.utils import ProtocolMixin
from aiida_abinit.workflows import AbinitBaseWorkChain
AbinitCalculation = CalculationFactory('abinit')


class AbinitBaseWorkChain(WorkChain, ProtocolMixin):
    """Base Abinit Workchain to perform a DFT calculation. Validates parameters and restart."""

    _process_class = AbinitCalculation

    @classmethod
    def define(cls, spec):
        """Define the process specification."""
        # yapf: disable
        super().define(spec)

        spec.expose_inputs(
            AbinitBaseWorkChain, namespace='scf', exclude=(
                'structure', 'clean_workdir',
            ),
            namespace_options={
                'help': 'Inputs for the `AbinitBaseWorkChain`.'
            }
        )

        spec.expose_inputs(
            AbinitBaseWorkChain, namespace='nscf', exclude=(
                'structure', 'clean_workdir',
            ),
            namespace_options={
                'help': 'Inputs for the `AbinitBaseWorkChain`.'
            }
        )
        spec.expose_inputs(
            AbinitBaseWorkChain, namespace='screening', exclude=(
                'structure', 'clean_workdir', 'kpoints', 'kpoints_distance',
            ),
            namespace_options={
                'help': 'Inputs for the `AbinitBaseWorkChain`.'
            }
        )
        spec.expose_inputs(
            AbinitBaseWorkChain, namespace='gw', exclude=(
                'structure', 'clean_workdir', 'kpoints', 'kpoints_distance',
            ),
            namespace_options={
                'help': 'Inputs for the `AbinitBaseWorkChain`.'
            }
        )

        spec.input('kpoints',
                   valid_type=orm.KpointsData,
                   required=False,
                   help='An explicit k-points mesh or list. Either this or `kpoints_distance` '
                        'must be provided.')
        spec.input('kpoints_distance',
                   valid_type=orm.Float,
                   required=False,
                   help='The minimum desired distance in 1/â„« between k-points in reciprocal space. The explicit '
                        'k-point mesh will be generated automatically by a calculation function based on the input '
                        'structure.')

        spec.outline(
            cls.setup,
            cls.validate_parameters,
            cls.run_scf,
            cls.run_nscf,
            cls.run_screening,
            cls.run_gw,
            cls.results,
        )


        spec.exit_code(401, 'ERROR_WORKCHAIN_SCF',
            message='The SCF calculation failed.')
        spec.exit_code(402, 'ERROR_WORKCHAIN_NSCF',
            message='The NSCF calculation failed.')
        spec.exit_code(403, 'ERROR_WORKCHAIN_SCREENING',
            message='The screening calculation failed.')
        spec.exit_code(404, 'ERROR_WORKCHAIN_GW',
            message='The GW calculation failed.')


    @classmethod
    def get_protocol_filepath(cls):
        """Return ``pathlib.Path`` to the ``.yaml`` file that defines the protocols."""
        from importlib_resources import files

        from . import protocols
        return files(protocols) / 'gw.yaml'

    @classmethod
    def get_builder_from_protocol(
        cls,
        code,
        structure,
        protocol=None,
        overrides=None,
        options=None,
        **_
        ):
        """Return a builder prepopulated with inputs selected according to the chosen protocol.

        :param code: the ``Code`` instance configured for the ``quantumespresso.epw`` plugin.
        :param protocol: protocol to use, if not specified, the default will be used.
        :param overrides: optional dictionary of inputs to override the defaults of the protocol.
        :param w90_chk_to_ukk_script: a julia script to convert the prefix.chk file (generated by wannier90.x) to a prefix.ukk file (to be used by epw.x)
        :return: a process builder instance with all inputs defined ready for launch.
        """
        from aiida_quantumespresso.workflows.protocols.utils import recursive_merge

        type_check(code, orm.Code)
        type_check(structure, orm.StructureData)
        
        inputs = cls.get_protocol_inputs(protocol, overrides)

        # Update the parameters based on the protocol inputs
        parameters = inputs['abinit']['parameters']

        # If overrides are provided, they are considered absolute
        if overrides:
            parameter_overrides = overrides.get('parameters', {})
            parameters = recursive_merge(parameters, parameter_overrides)

        metadata = inputs['abinit'].pop('metadata')

        if options:
            metadata['options'] = recursive_merge(metadata['options'], options)

        # pylint: disable=no-member
        builder = cls.get_builder()
        builder['abinit'].structure = structure
        builder['abinit'].code = code
        builder['abinit'].parameters = orm.Dict(parameters)
        ## Must firstly pop the options from the metadata dictionary.
        
        pseudo_family = orm.Group.collection.get(label=inputs['pseudo_family'])
        pseudos = pseudo_family.get_pseudos(structure=structure)
        builder['abinit']['pseudos'] = pseudos

        builder['abinit']['metadata'] = metadata

        if 'settings' in inputs['abinit']:
            builder['abinit']['settings'] = orm.Dict(inputs['abinit']['settings'])
        if 'parallelization' in inputs['abinit']:
            builder['abinit']['parallelization'] = orm.Dict(inputs['abinit']['parallelization'])

        builder.clean_workdir = orm.Bool(inputs['clean_workdir'])
        builder.kpoints_distance = orm.Float(inputs['kpoints_distance'])
        builder.max_iterations = orm.Int(inputs['max_iterations'])
        # pylint: enable=no-member

        return builder

    def setup(self):
        """Call the `setup` of the `BaseRestartWorkChain` and then create the inputs dictionary in `self.ctx.inputs`.

        This `self.ctx.inputs` dictionary will be used by the `BaseRestartWorkChain` to submit the calculations in the
        internal loop.
        """
        super().setup()
        self.ctx.restart_calc = None
        self.ctx.inputs = AttributeDict(self.exposed_inputs(AbinitCalculation, 'abinit'))

    def validate_parameters(self):
        """Validate inputs that might depend on each other and cannot be validated by the spec.

        Also define dictionary `inputs` in the context, that will contain the inputs for the calculation that will be
        launched in the `run_calculation` step.
        """
        super().setup()
        self.ctx.inputs.parameters = self.ctx.inputs.parameters.get_dict()
        self.ctx.inputs.settings = self.ctx.inputs.settings.get_dict() if 'settings' in self.ctx.inputs else {}
        self.ctx.inputs.parameters.setdefault('ecut', 8.0)

    def run_scf(self):
        """Run the SCF calculation."""
        inputs = AttributeDict(
            self.exposed_inputs(AbinitBaseWorkChain, namespace='w90_bands')
        )
        inputs.metadata.call_link_label = 'scf'
        inputs.structure = self.inputs.structure

        workchain_node = self.submit(AbinitBaseWorkChain, **inputs)
        self.report(f'launching AbinitBaseWorkChain<{workchain_node.pk}>')

        return ToContext(workchain_w90_bands=workchain_node)

    def inspect_scf(self):
        """Verify that the SCF calculation finished successfully."""
        workchain = self.ctx.workchain_scf

        if not workchain.is_finished_ok:
            self.report(f'AbinitBaseWorkChain<{workchain.pk}> failed with exit status {workchain.exit_status}')
            return self.exit_codes.ERROR_WORKCHAIN_SCF

    def run_nscf(self):
        """Run the NSCF calculation."""
        inputs = AttributeDict(
            self.exposed_inputs(AbinitBaseWorkChain, namespace='nscf')
        )
        inputs.abinit.parent_calc_folder = self.ctx.workchain_scf.outputs.remote_folder
        inputs.metadata.call_link_label = 'nscf'
        inputs.structure = self.inputs.structure
        workchain_node = self.submit(AbinitBaseWorkChain, **inputs)
        self.report(f'launching AbinitBaseWorkChain<{workchain_node.pk}>')
        return ToContext(workchain_nscf=workchain_node)

    def inspect_nscf(self):
        """Verify that the NSCF calculation finished successfully."""
        workchain = self.ctx.workchain_nscf

        if not workchain.is_finished_ok:
            self.report(f'AbinitBaseWorkChain<{workchain.pk}> failed with exit status {workchain.exit_status}')
            return self.exit_codes.ERROR_WORKCHAIN_NSCF

    def run_screening(self):
        """Run the screening calculation."""
        inputs = AttributeDict(
            self.exposed_inputs(AbinitBaseWorkChain, namespace='screening')
        )
        inputs.abinit.parent_calc_folder = self.ctx.workchain_nscf.outputs.remote_folder
        inputs.metadata.call_link_label = 'screening'
        inputs.structure = self.inputs.structure
        workchain_node = self.submit(AbinitBaseWorkChain, **inputs)
        self.report(f'launching AbinitBaseWorkChain<{workchain_node.pk}>')
        return ToContext(workchain_screening=workchain_node)

    def inspect_screening(self):
        """Verify that the screening calculation finished successfully."""
        workchain = self.ctx.workchain_screening

        if not workchain.is_finished_ok:
            self.report(f'AbinitBaseWorkChain<{workchain.pk}> failed with exit status {workchain.exit_status}')
            return self.exit_codes.ERROR_WORKCHAIN_SCREENING

    def run_gw(self):
        """Run the GW calculation."""
        inputs = AttributeDict(
            self.exposed_inputs(AbinitBaseWorkChain, namespace='gw')
        )
        inputs.abinit.parent_calc_folder = self.ctx.workchain_screening.outputs.remote_folder
        inputs.metadata.call_link_label = 'gw'
        inputs.structure = self.inputs.structure
        workchain_node = self.submit(AbinitBaseWorkChain, **inputs)
        self.report(f'launching AbinitBaseWorkChain<{workchain_node.pk}>')
        return ToContext(workchain_gw=workchain_node)

    def inspect_gw(self):
        """Verify that the GW calculation finished successfully."""
        workchain = self.ctx.workchain_gw

        if not workchain.is_finished_ok:
            self.report(f'AbinitBaseWorkChain<{workchain.pk}> failed with exit status {workchain.exit_status}')
            return self.exit_codes.ERROR_WORKCHAIN_GW

    def results(self):
        """Collect the results from the calculations."""
        self.out('scf', self.ctx.workchain_scf.outputs.output_parameters)
        self.out('nscf', self.ctx.workchain_nscf.outputs.output_parameters)
        self.out('screening', self.ctx.workchain_screening.outputs.output_parameters)
        self.out('gw', self.ctx.workchain_gw.outputs.output_parameters)